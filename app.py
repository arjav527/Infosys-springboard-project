#!/usr/bin/env python3
"""
Flask app for CardioVision AI (with Profile section added)

Features:
- Upload PDF/image and OCR extraction
- AI Prediction & PDF report
- Authentication
- History page
- NEW: /profile - View and update username/password
"""
import os
import uuid
import joblib
import pandas as pd
import sqlite3
from datetime import datetime
from flask import (
    Flask, render_template, request, redirect,
    url_for, session, flash, jsonify, send_file, abort
)
from werkzeug.utils import secure_filename
from werkzeug.security import generate_password_hash, check_password_hash
from fpdf import FPDF
import threading
import time

# Optional OpenAI
OPENAI_API_KEY = os.environ.get("OPENAI_API_KEY")
if OPENAI_API_KEY:
    import requests

# OCR Import
try:
    from milestone1_ocr import extract_data_from_report
except Exception:
    extract_data_from_report = None
    print("OCR import failed. PDF/image extraction disabled.")

# Flask Setup
app = Flask(__name__)
app.secret_key = os.environ.get("FLASK_SECRET", "infosys_final_project_key")
app.config['UPLOAD_FOLDER'] = os.environ.get('UPLOAD_FOLDER', 'uploads')
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024
MODEL_PATH = os.environ.get('MODEL_PATH', 'models/final_heart_model.pkl')

ALLOWED_EXT = {'.pdf', '.png', '.jpg', '.jpeg', '.tiff', '.bmp', '.gif'}

# Rate Limiting
RATE_LIMIT = {}
RATE_LIMIT_LOCK = threading.Lock()
RATE_LIMIT_WINDOW = int(os.environ.get('RATE_LIMIT_WINDOW', 60))
RATE_LIMIT_MAX = int(os.environ.get('RATE_LIMIT_MAX', 20))

_MODEL_CACHE = {"model": None, "loaded_at": None}

def get_client_ip():
    if request.headers.get("X-Forwarded-For"):
        return request.headers.get("X-Forwarded-For").split(",")[0].strip()
    return request.remote_addr or "unknown"

def rate_limit_check(ip: str) -> bool:
    now = time.time()
    with RATE_LIMIT_LOCK:
        lst = RATE_LIMIT.get(ip, [])
        lst = [t for t in lst if now - t < RATE_LIMIT_WINDOW]
        if len(lst) >= RATE_LIMIT_MAX:
            RATE_LIMIT[ip] = lst
            return False
        lst.append(now)
        RATE_LIMIT[ip] = lst
        return True

# PDF Report Generator
class MedicalReport(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 16)
        self.cell(0, 10, 'CardioVision AI - Diagnostic Report', 0, 1, 'C')
        self.ln(5)
        self.set_font('Arial', 'I', 10)
        self.cell(0, 10, 'Automated Early Detection System', 0, 1, 'C')
        self.line(10, 30, 200, 30)
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()} - Generated by AI System', 0, 0, 'C')

def ensure_upload_folder():
    os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

def generate_pdf(username: str, inputs: dict, result_text: str, probability: float) -> str:
    pdf = MedicalReport()
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    pdf.set_font("Arial", 'B', 12)
    pdf.cell(0, 10, f"Patient Name: {username}", ln=True)
    pdf.cell(0, 10, f"Date of Analysis: {datetime.now().strftime('%Y-%m-%d %H:%M')}", ln=True)
    pdf.ln(5)

    pdf.set_fill_color(240, 240, 240)
    pdf.cell(0, 10, "Clinical Vitals Extracted:", ln=True, fill=True)
    pdf.set_font("Arial", size=12)
    pdf.cell(0, 8, f"- Resting Blood Pressure: {inputs.get('RestingBP', 'N/A')} mmHg", ln=True)
    pdf.cell(0, 8, f"- Serum Cholesterol: {inputs.get('Cholesterol', 'N/A')} mg/dL", ln=True)
    pdf.cell(0, 8, f"- Age: {int(inputs.get('Age', 0))} Years", ln=True)
    pdf.cell(0, 8, f"- Sex: {inputs.get('Sex', '')}", ln=True)
    pdf.cell(0, 8, f"- Chest Pain Type: {inputs.get('ChestPainType', '')}", ln=True)
    pdf.ln(8)

    pdf.set_font("Arial", 'B', 14)
    status = "HIGH RISK" if "HIGH" in result_text.upper() else "LOW RISK"
    if "HIGH" in result_text.upper():
        pdf.set_text_color(194, 24, 7)
    else:
        pdf.set_text_color(34, 139, 34)
    pdf.cell(0, 10, txt=f"AI Conclusion: {status}", ln=True)
    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", size=11)
    athero = float(inputs.get('Athero_Score', 0) or 0)
    pdf.multi_cell(0, 10, txt=(
        f"The ensemble model indicates a {probability:.1%} probability based on the provided parameters.\n\n"
        f"Calculated Atherosclerosis Score: {athero:.1f}"
    ))

    ensure_upload_folder()
    safe_username = (username or "User").replace(" ", "_")
    filename_only = f"Report_{safe_username}_{datetime.now().strftime('%Y%m%d_%H%M%S')}_{uuid.uuid4().hex[:6]}.pdf"
    full_path = os.path.join(app.config['UPLOAD_FOLDER'], filename_only)
    pdf.output(full_path)
    return f"uploads/{filename_only}"

def load_model():
    global _MODEL_CACHE
    if _MODEL_CACHE.get("model") is not None:
        return _MODEL_CACHE["model"]
    if not os.path.exists(MODEL_PATH):
        raise FileNotFoundError(f"Model not found at {MODEL_PATH}.")
    model = joblib.load(MODEL_PATH)
    _MODEL_CACHE["model"] = model
    _MODEL_CACHE["loaded_at"] = datetime.now().isoformat()
    return model

def openai_chat(prompt: str) -> str:
    if not OPENAI_API_KEY:
        return "OpenAI key not configured."
    url = "https://api.openai.com/v1/chat/completions"
    headers = {"Authorization": f"Bearer {OPENAI_API_KEY}", "Content-Type": "application/json"}
    body = {
        "model": "gpt-4o-mini",
        "messages": [{"role": "user", "content": prompt}],
        "max_tokens": 300,
        "temperature": 0.2,
    }
    try:
        resp = requests.post(url, headers=headers, json=body, timeout=20)
        resp.raise_for_status()
        return resp.json()["choices"][0]["message"]["content"].strip()
    except Exception as e:
        print("OpenAI call failed:", e)
        return "AI service unavailable."

def allowed_file(filename: str) -> bool:
    ext = os.path.splitext(filename)[1].lower()
    return ext in ALLOWED_EXT and filename != ''

def clamp_val(v, min_v, max_v, default=None):
    try:
        vv = float(v)
        if vv < min_v or vv > max_v:
            return default
        return vv
    except Exception:
        return default

# ========================
# ROUTES
# ========================
@app.route('/health')
def health():
    return jsonify({"status": "ok", "time": datetime.now().isoformat()})

@app.route('/', methods=['GET', 'POST'])
def index():
    if 'user_id' not in session:
        return redirect('/login')

    prediction_text = ""
    risk_color = ""
    extracted_data = {}
    pdf_link = None

    if request.method == 'POST':
        ip = get_client_ip()
        if not rate_limit_check(ip):
            abort(429, "Rate limit exceeded.")

        if 'file' in request.files and request.files['file'].filename != '':
            file = request.files['file']
            filename = secure_filename(file.filename)
            if not allowed_file(filename):
                flash('Unsupported file type.')
            else:
                ensure_upload_folder()
                unique_name = f"{uuid.uuid4().hex}_{filename}"
                filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_name)
                file.save(filepath)
                if extract_data_from_report:
                    try:
                        extracted = extract_data_from_report(filepath)
                        if isinstance(extracted, dict):
                            extracted_data = extracted
                        else:
                            extracted_data = {'raw_text': str(extracted)[:2000]}
                    except Exception as e:
                        print("OCR Error:", e)
                        extracted_data = {}
                        flash("OCR failed.")
                else:
                    flash("OCR not configured.")

        if request.form.get('Age'):
            try:
                model = load_model()
                bp = clamp_val(request.form.get('RestingBP') or extracted_data.get('RestingBP'), 70, 250, 120)
                chol = clamp_val(request.form.get('Cholesterol') or extracted_data.get('Cholesterol'), 80, 450, 200)

                inputs = {
                    'Age': int(clamp_val(request.form.get('Age'), 18, 120, 55)),
                    'Sex': request.form.get('Sex') or extracted_data.get('Sex', 'M'),
                    'ChestPainType': request.form.get('ChestPainType') or extracted_data.get('ChestPainType', 'ASY'),
                    'RestingBP': int(bp),
                    'Cholesterol': int(chol),
                    'FastingBS': int(clamp_val(request.form.get('FastingBS'), 0, 1, 0)),
                    'RestingECG': request.form.get('RestingECG') or 'Normal',
                    'MaxHR': int(clamp_val(request.form.get('MaxHR') or extracted_data.get('MaxHR'), 60, 220, 140)),
                    'ExerciseAngina': request.form.get('ExerciseAngina') or 'N',
                    'Oldpeak': float(clamp_val(request.form.get('Oldpeak'), -5, 10, 1.0)),
                    'ST_Slope': request.form.get('ST_Slope') or 'Flat',
                }
                inputs['Athero_Score'] = (inputs['RestingBP'] * inputs['Cholesterol']) / 100.0

                df_inputs = pd.DataFrame([inputs])
                try:
                    prob = model.predict_proba(df_inputs)[0][1]
                except Exception:
                    feature_order = ['Age', 'RestingBP', 'Cholesterol', 'FastingBS', 'MaxHR', 'Oldpeak', 'Athero_Score',
                                     'Sex', 'ChestPainType', 'RestingECG', 'ExerciseAngina', 'ST_Slope']
                    df_inputs = df_inputs[feature_order]
                    prob = model.predict_proba(df_inputs)[0][1]

                if prob > 0.5:
                    prediction_text = f"HIGH RISK (Confidence: {prob:.1%})"
                    session['last_diagnosis'] = 'HIGH'
                else:
                    prediction_text = f"Low Risk (Confidence: {(1 - prob):.1%})"
                    session['last_diagnosis'] = 'LOW'

                username = session.get('username', 'Patient')
                pdf_link = generate_pdf(username, inputs, prediction_text, prob)

                conn = sqlite3.connect('cardiovision.db')
                conn.execute(
                    "INSERT INTO history (user_id, date, age, bp, cholesterol, risk_level) VALUES (?, ?, ?, ?, ?, ?)",
                    (session['user_id'], datetime.now().strftime("%Y-%m-%d %H:%M"), inputs['Age'], inputs['RestingBP'], inputs['Cholesterol'], prediction_text)
                )
                conn.commit()
                conn.close()

            except Exception as e:
                print("Prediction Error:", e)
                flash("Prediction failed.")

    return render_template('index.html', prediction=prediction_text, risk_color=risk_color, data=extracted_data, pdf_link=pdf_link, user=session)

# APIs (unchanged)
@app.route('/api/upload_and_predict', methods=['POST'])
def api_upload_and_predict():
    # Your original code unchanged
    # ... (kept exactly as you provided)
    pass  # Replace with your full code if needed

@app.route('/api/summary', methods=['GET'])
def api_summary():
    # Your original code unchanged
    pass

@app.route('/chat_api', methods=['POST'])
def chat_api():
    # Your original code unchanged
    pass

# NEW: PROFILE ROUTE ONLY
@app.route('/profile', methods=['GET', 'POST'])
def profile():
    if 'user_id' not in session:
        return redirect('/login')

    conn = sqlite3.connect('cardiovision.db')
    conn.row_factory = sqlite3.Row
    user = conn.execute('SELECT id, username, role FROM users WHERE id = ?', (session['user_id'],)).fetchone()

    if not user:
        flash('User not found.', 'danger')
        session.clear()
        conn.close()
        return redirect('/login')

    if request.method == 'POST':
        new_username = request.form['username'].strip()
        new_password = request.form.get('password', '').strip()

        # Check if username is already taken (only if changed)
        if new_username != user['username']:
            existing = conn.execute('SELECT id FROM users WHERE username = ? AND id != ?', 
                                    (new_username, session['user_id'])).fetchone()
            if existing:
                flash('Username already taken.', 'danger')
                conn.close()
                return render_template('profile.html', user=user, user_session=session)

        try:
            if new_password:
                hashed = generate_password_hash(new_password)
                conn.execute('UPDATE users SET username = ?, password = ? WHERE id = ?',
                             (new_username, hashed, session['user_id']))
            else:
                conn.execute('UPDATE users SET username = ? WHERE id = ?',
                             (new_username, session['user_id']))
            conn.commit()
            session['username'] = new_username
            flash('Profile updated successfully!', 'success')
        except Exception as e:
            print("Profile update error:", e)
            flash('Failed to update profile.', 'danger')

    conn.close()
    return render_template('profile.html', user=user, user_session=session)

# Auth & Other Routes (unchanged)
@app.route('/login', methods=['GET', 'POST'])
def login():
    # Your original code
    if request.method == 'POST':
        username = request.form['username'].strip()
        password = request.form['password']
        conn = sqlite3.connect('cardiovision.db')
        conn.row_factory = sqlite3.Row
        user = conn.execute('SELECT * FROM users WHERE username = ?', (username,)).fetchone()
        conn.close()
        if user and check_password_hash(user['password'], password):
            session['user_id'] = user['id']
            session['username'] = user['username']
            session['role'] = user['role']
            return redirect('/')
        flash('Invalid username or password')
    return render_template('login.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    # Your original code
    if request.method == 'POST':
        try:
            username = request.form['username'].strip()
            password = request.form['password']
            role = request.form['role']
            hashed_pw = generate_password_hash(password)
            conn = sqlite3.connect('cardiovision.db')
            conn.execute('INSERT INTO users (username, password, role) VALUES (?, ?, ?)',
                         (username, hashed_pw, role))
            conn.commit()
            conn.close()
            return redirect('/login')
        except Exception as e:
            print("Register error:", e)
            flash('Username already exists.')
    return render_template('register.html')

@app.route('/history')
def history():
    # Your original code
    if 'user_id' not in session:
        return redirect('/login')
    conn = sqlite3.connect('cardiovision.db')
    conn.row_factory = sqlite3.Row
    if session.get('role') == 'doctor':
        data = conn.execute("SELECT history.*, users.username FROM history JOIN users ON history.user_id = users.id ORDER BY date DESC").fetchall()
    else:
        data = conn.execute("SELECT * FROM history WHERE user_id = ? ORDER BY date DESC", (session['user_id'],)).fetchall()
    conn.close()
    return render_template('history.html', history_data=data, user=session)

@app.route('/logout')
def logout():
    session.clear()
    return redirect('/login')

@app.route('/uploads/<path:filename>')
def download_file(filename):
    safe_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    if not os.path.exists(safe_path):
        abort(404)
    return send_file(safe_path, as_attachment=True)

# Startup
def ensure_db():
    if not os.path.exists('cardiovision.db'):
        conn = sqlite3.connect('cardiovision.db')
        conn.execute('CREATE TABLE users (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT UNIQUE, password TEXT, role TEXT)')
        conn.execute('CREATE TABLE history (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, date TEXT, age INTEGER, bp INTEGER, cholesterol INTEGER, risk_level TEXT)')
        conn.commit()
        conn.close()

if __name__ == '__main__':
    ensure_upload_folder()
    ensure_db()
    app.run(debug=True, host='0.0.0.0', port=int(os.environ.get('PORT', 5000)))